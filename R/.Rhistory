TgridVAR=function(Ni, SSigma_eps, A, m){
#Defines the length of the random vector of the process
M = length(Ni)
#Initializes values for the grid, variances matrix of the vector, and lenght of step for each dimension
grid = vector(mode = "list", length = M)
SSigma_y = matrix(0,M,M)
w = rep(0,M)
#Vectorization of white noise variances matrix
vec_SSigma_eps = matrix(c(SSigma_eps))
#Computes the vectorized unconditional variance of the random vector
if(M==1){
vec_SSigma_y = solve(1 - kronecker(A,A)) %*% vec_SSigma_eps
}
else{
vec_SSigma_y = solve(diag(M^2) - kronecker(A,A)) %*% vec_SSigma_eps
}
#Converts the result to a matrix of variances
SSigma_y = matrix(vec_SSigma_y,M,M)
#Obtains the standard deviations asociated with the matrix
ssigma_y = sqrt(diag(SSigma_y))
#Sets the values for the lenght of steps of the gird accordingly for each component
w = 2*m*ssigma_y/(Ni-1)
#Creates a list in which each element is the grid for each component of y_t
for(j in 1:M){
aux_vec_yi = -m*ssigma_y[j] + c(0:(Ni[j]-1))*w[j]
grid[[j]]= aux_vec_yi
}
#Returns the list with the grid for each dimension
return(grid)
}
Tstates_grid=function(Ni, SSigma_eps, A, m){
grid = TgridVAR(Ni, SSigma_eps, A, m)
states_grid = expand.grid(grid)
rownames(states_grid) = paste0("state", seq_len(nrow(states_grid)))
colnames(states_grid) = paste0("y", seq_len(ncol(states_grid)))
states_grid = data.matrix(states_grid)
return(states_grid)
}
Tstates_grid_index=function(Ni){
M = length(Ni)
grid_index = vector(mode = "list", length = M)
for(j in 1:M){
aux_vec_l = c(1:(Ni[j]))
grid_index[[j]]= aux_vec_l
}
states_grid_index = expand.grid(grid_index)
rownames(states_grid_index) = paste0("state", seq_len(nrow(states_grid_index)))
colnames(states_grid_index) = paste0("y", seq_len(ncol(states_grid_index)))
states_grid_index = data.matrix(states_grid_index)
return(states_grid_index)
}
RtauchenVAR=function(Ni, SSigma_eps, A, m){
#Takes the lenght of the vector
M = length(Ni)
#Takes the number of states of the MArkov chain
N_star = prod(Ni)
#Obtains the grid for each dimension
grid = TgridVAR(Ni, SSigma_eps, A, m)
states_grid = Tstates_grid(Ni, SSigma_eps, A, m)
states_grid_index = Tstates_grid_index(Ni)
#obtains the variances and places them accordingly
if(M==1){
vec_SSigma_eps = matrix(c(SSigma_eps))
vec_SSigma_y = solve(1 - kronecker(A,A)) %*% vec_SSigma_eps
}else{
vec_SSigma_eps = matrix(c(SSigma_eps))
vec_SSigma_y = solve(diag(M^2) - kronecker(A,A)) %*% vec_SSigma_eps
}
SSigma_y = matrix(vec_SSigma_y,M,M)
ssigma_y = sqrt(diag(SSigma_y))
SSigma_eps = matrix(vec_SSigma_eps,M,M)
ssigma_eps = sqrt(diag(SSigma_eps))
#Sets the length of the step for each dimension
w = 2*m*ssigma_y/(Ni-1)
#Initializes the list to storage the transition probabilities for each diemnsion
h = vector(mode = "list", length = N_star)
for(j in 1:N_star){
h[[j]]= grid
}
#Computes the transition probabilities for each dimension of each state, as in Tauchen(1986).
#h[[j]][[i]][l] is the probability that, starting in state j, the dimension i of the vector
#takes the value l of the grid for that dimension, on the next state.
for(j in 1:N_star){
y=states_grid[j,]
mu=A%*%y
for(i in 1:M){
if(Ni[i] > 1){
for(l in 1:Ni[i]){
if(l == 1){
h[[j]][[i]][l] = pnorm((grid[[i]][l] - mu[i] +(w[i]/2))/ssigma_eps[i])
}else if(l == Ni[i]){
h[[j]][[i]][l] = 1- pnorm((grid[[i]][l] - mu[i]-(w[i]/2))/ssigma_eps[i])
}else{
h[[j]][[i]][l] = pnorm((grid[[i]][l] - mu[i] +(w[i]/2))/ssigma_eps[i])-pnorm((grid[[i]][l]-mu[i]-(w[i]/2))/ssigma_eps[i])
}
}
}
else{
h[[j]][[i]][i] = 1
}
}
}
#Initializes the transition matrix for the Markov chain
P = array(0, dim = c(N_star,N_star))
#Generates the transition probabilities form state j to state k as in Tauchen(1986).
#For each state, all the probabilities of transition for each dimension are stored
#in  data.matrix(expand.grid(h[[j]])). Then, byu independence, the probability of changing
#state is the product of the probability of changing value in each dimension.
for(j in 1:N_star){
aux_matrix = data.matrix(expand.grid(h[[j]]))
for(k in 1:N_star){
P[j,k]=prod(aux_matrix[k,])
}
}
return(P)
}
# This example computes the transition probability matrix of the finite-state Markov chain approximation of an AR(1) process with:
# n = 5 points in the Markov chain
# ssigma = 0.02
# lambda = 0.95
# m = 3
results1 = Rtauchen(5, 0.02, 0.98, 3)
library(Rtauchen)
# This example computes the transition probability matrix of the finite-state Markov chain approximation of an AR(1) process with:
# n = 5 points in the Markov chain
# ssigma = 0.02
# lambda = 0.95
# m = 3
results1 = Rtauchen(5, 0.02, 0.98, 3)
results2 = RtauchenVAR(5, 0.02^2, 0.98, 3)
print(results1-results2)
A1=matrix(c(0.7,0.3,0.2,0.5),ncol=2)
Ni1=c(5,5)
SSigma_eps1=diag(2)*(0.02^2)
m1=3
A=matrix(c(0.7,0.3,0.2,0.5),ncol=2)
Ni=c(5,5)
SSigma_eps=diag(2)*(0.02^2)
m=3
results3 = RtauchenVAR(Ni, SSigma_eps, A, m)
print(results3)
for (i in 1:prod(Ni)) {
print(sum(results3[i,]))
}
grid = TgridVAR(Ni, SSigma_eps, A, m)
grid
for (i in 1:length(Ni)) {
print(grid[[i]])
}
A=matrix(c(0.7,0.3,0.2,0.5),ncol=2)
Ni=c(3,5)
SSigma_eps=diag(2)*(0.02^2)
m=3
#Muestra la lista con la grid para cada dimensi√≥n
grid = TgridVAR(Ni, SSigma_eps, A, m)
print(grid)
for (i in 1:length(Ni)) {
print(grid[[i]])
}
results3 = RtauchenVAR(Ni, SSigma_eps, A, m)
print(results3)
for (i in 1:prod(Ni)) {
print(sum(results3[i,]))
}
statesgrid = Tstates_grid(Ni, SSigma_eps, A, m)
print(statesgrid)
statesgridindex = Tstates_grid_index(Ni, SSigma_eps, A, m)
print(statesgridindex)
statesgridindex = Tstates_grid_index(Ni)
print(statesgridindex)
